# GolangTrainer

Вам нужно написать небольшой сервис, который мы назовём Slowly.
Основная функциональность
Сервис принимает запросы по протоколу HTTP (если сделаете поддержку HTTP2 - будет плюсом).

Запрос должен выглядеть следующим образом:
POST /api/slow
Content-Type: application/json

{
    "timeout": 3000 // время в мс
}

Ответ приходит через указанное количество времени (поле timeout):
HTTP 200 OK
Content-Type: application/json

{
    "status": "ok"
}

На все другие запросы должен приходить ответ HTTP 404 Not Found
Middleware
Поскольку пользователи начали злоупотреблять сервисом, было решено написать Middleware, которое "отрубает" обработчики, ожидающие больше 5 секунд. Реализуйте подобное Middleware: для всех подобных ошибок, должен возвращаться ответ:
HTTP 400 Bad Request
Content-Type: application/json

{
    "error": "timeout too long"
}
Результаты
Напишите автотесты на Happy Path (на код 200) и Sad Path (на код 400). Организация и используемые инструменты - на ваше усмотрение
Выложите весь код на Github (при необходимости комментарии можете написать в README.md)
Подключите какой-нибудь облачный CI, который будет запускать тесты - Github Actions, Travis CI или любой другой на ваше усмотрение
Пришлите нам ссылку на ваш репо

Важно: вы сами решаете как организовать код, как покрывать его тестами (с учётом требований) и т.д. - представьте, что вы готовите пример, чтобы объяснить человеку, как (с вашей точки зрения) "делать правильно".

После того, как вы напишите код, мы предлагаем вам потренироваться в роли преподавателя/тренера и попробовать ответить на те вопросы, которые задают студенты (мы пришлём эти вопросы вам в ответ на ваш код). Обратите внимание, что студенты не знают терминологии, не учились на программистов (у них вообще может не быть высшего образования). Поэтому при ответе объясняйте так, как объясняли бы студентам.

Понятность и доступность вашего объяснения - ключевое для нас.

# Описание функционала
Сначала требуется запустить сервер для получения запросов от клиентов и прописать нужные маршруты.
Маршрут /api/slow будет отдавать статус 200, а все остальное 404. Для этого нужно создать обработчики
для /api/slow маршрута и дефолтного /, если маршрут не будет найден. Данные передавать клиенту и получать
только в формате JSON. Маршрут /api/slow должен использовать метод POST и принимать параметр timeout числового 
или строкового типа. В обработчике /api/slow сделать неблокирующее ожидание функции на величину параметра
timeout в мс. Для этого мы используем в миддлвейре канал для передачи информации о завершении обработчика и 
его ожидания миддлевейру. Канал будем передавать в фоновый запуск обработчиков, что бы записать в него ответ о завершении.
В миддлвейре мы будем слушать на получение данных не только ответ от обработчиков. Задача регламентирует, обрывать
все запросы которые более 5 секунд. Для этого мы создадим таймер, который будем слушать на получение данных при истечении
времени. При срабатывании таймера отдать код статуса 400. В итоге мы получаем функционал обработки ошибок 404 через обработчик
по умолчанию. Обработка с неблокирующим ожиданием маршрута /api/slow. Миддлвейр следящий за дедлайном и работающими обработчиками
,который будет отдавать ответ клиенту.

# План действий
- Запустить сервер на 8080 порту
- Добавить дефолтный маршрут "/" и обработчик на отдачу статуса 404
- Добавить миддлвейр с таймером на прерывание запроса 5 секунд
- Добавить в миддлвейр поиск обработчика по пути.
- Вызывать обработчик в фоновой функции что бы не блокировать ожиданием основной поток.
- Реализовать канал для передачи в фоновую функцию где выполняются обработчики
- Слушать канал таймера дедлайна и канал завершения обработчика
- При получении данных с канала таймера через 5 сек. отдать статус 400 клиенту
- Если обработчик быстрее отправит в свой канал данные, то миддлвейр должен отдать
  статус 200 клиенту и JSON тело ``{"status": "ok"}``

# Пошаговое описание
Что бы создать этот сервис, нам нужно выполнить следующий список шагов
- Создайте файл main.go и напишите в нем главную функцию. 
    ```go
    func main() {
    
    }
    ```
- В функции main создадим mux(роутер, мультиплексор), для хранения в нем обработчиков и путей. 
    ```go
    mux := http.NewServeMux()
    ```
- Добавим в роутер маршрут(путь), как регламентирует задача. 
    ```go
    mux.Handle("/api/slow", nil)
    ```
    ``
    ℹ️ Обратите внимание, что мы в качестве обработчика передали nil, так как пока не создали его.
    ``
- Теперь инициализируем сервер который будет принимать запросы
    ```go
    srv := http.Server{
   	Addr:    ":8080",
   	Handler: mux,
    }
    ```
    ``
    ℹ️ Обратите внимание, что мы в качестве обработчика передали mux, для обработки маршрутов.
    ``
- Далее закроем сервер когда функция main закончит свою работу
    ```go
    defer func() {
      _ = srv.Close()
    }()
    ```
- Осталось только запустить сервер на прослушивание. Мы будем использовать порт 8080.
    ```go
    fmt.Printf("Listening [127.0.0.1:8080]...\n") // Вывод в консоль
    if err := srv.ListenAndServe(); err != nil { // Слушаем порт
        fmt.Printf("Server failed: %s\n", err) // Если произошла ошибка выведем в консоль
    }
    ```
- Создадим файл с обработчиками. Назовем его ``handlers.go`` и вставим в него следующий текст 
    ```go
    package main
    import (
    	"encoding/json"
    	"io/ioutil"
    	"log"
    	"net/http"
    	"strconv"
    	"time"
    )
    
    // Структура для входящих параметров
    type bodyParams struct {
      // Интерфейс используется для приема типа строка или целое
      Timeout interface{} `json:"timeout"` // Таймаут в миллисек
    }
    
    /* Функция обработчик для пути /api/slow
     * Выполняет задержку функции на параметр Timeout
     * Возвращает ошибку 404 или записывает в канал "ready"
     * статус булева, для опработки успешного ответа.
     */ 
    func slowHandle(w http.ResponseWriter, r *http.Request) {  
      // Обрабатываем только пост
      if r.Method == "POST" {  
    	// Селектор для выбора маршрута
    	switch r.URL.Path {
    	  case "/api/slow":
    	  // Сейчас нам нужно получить тело запроса 	
  	      // и выгрузить его в структуру bodyParams
  	      bd, err := ioutil.ReadAll(r.Body)
    	  if err != nil { // Всегда обрабатываем ошибки
    	    http.Error(w, "", 404)
    	    return
    	  }
    
    	  var b bodyParams
    	  // Так как наше тело запроса(body) имеет формат данных 		
  	      // application/json, используем декодер json 	
	      // Записываем тело в экземпляр структуры b
  	      err = json.Unmarshal(bd, &b)
  	      if err != nil {
    	    http.Error(w, "", 404)
    	    return
    	  }
    
    	  var timeout time.Duration
    	  // Определяем тип входящего параметра таймаут
    	  switch tm := b.Timeout.(type) {
    	  case float64: // Если число
    	    timeout = time.Duration(tm.(int64)) * time.Millisecond 
    	  case string: // Если строка
    	    convTm, err := strconv.Atoi(tm.(string)) // Конвертируем в число
    	    if err != nil {
    	      log.Printf("Errpr: %v", err)
    	    }
    	    timeout = time.Duration(convTm) * time.Millisecond
    	  }
    
    	  // Теперь когда мы получили значение Timeout
    	  // Запускаем таймер для ожидания функции
    	  timer := time.NewTimer(timeout)
    
    	  select {
    	  case <-timer.C:
    	    // Таймер сработал, передаем сообщение о успехе
    	    // Достаем с контекста канал для уведомления завершения функции
    	    if ch, ok := r.Context().Value("ready").(chan bool); ok {
    	      // Отправляем в канал статус "найдено" то есть true
    	      // Что бы получить данные из канала и отдать результат
    	      // браузеру. Статус найдено имеет код HTTP 200 
    	      ch <- true
    	    }
    	  }
    	  return // Возвращаем функцию что бы не выполнилась ошибка ниже
    	}
      }  
      http.Error(w, "", 404)
    }
    
    // Добавим обработчик по умолчанию
    // Если маршрут не будет найден то отдаем 404 с пустым телом
    func defaultHandler(w http.ResponseWriter, r *http.Request) {
      if ch, ok := r.Context().Value("ready").(chan bool); ok {
        // Отправляем в канал статус "не найдено" то есть false
        // Что бы получить данные из канала и отдать результат
        // браузеру. Статус не найдено имеет код HTTP 404 
        ch <- false 
      }
      return
    }

    ```
- Вернемся в файл ``main.go`` и добавим обработчики
    ```go
    mux.Handle("/api/slow", http.HandlerFunc(slowHandle)) // Добавляем  вместо nil обработчик
    
    // Еще давайте добавим в роутер обработчик по умолчанию, на случай
    // если путь не будет найден
    mux.Handle("/", http.HandlerFunc(defaultHandler)) // Выберется если путь не найден или  
    ```
- Осталось сделать фильтрацию для прерывания запросов которые длятся более 5 секунд. Создадим файл ``middleware.go`` 
  и вставим в него следующий код.
    ```go
    package main
    
    import (
    	"context"
    	"encoding/json"
    	"log"
    	"net/http"
    	"time"
    )

    /*
    * Прослойка(Миддлвейр) для фильтрации и прерывания запросов 
    * которые выполняются более 5 секунд. Так же выполняет роль
    * слушателя за каналом дедлайна(5 сек) и каналом возврата статуса
    * обработчиков роутера  
    */
    func filterMiddleware(mux *http.ServeMux) http.HandlerFunc {  
      return func(w http.ResponseWriter, r *http.Request) {
        // Инициализация канала возврата статуса от обработчиков slowHandle и defaultHandler 
        ready := make(chan bool) // true - найден, false - не найден
      
        // Создаем контекст на основе запроса со значением
        // Записываем канал в контекст что бы достать его в обработчике
        // Прим. - r.Context().Value("ready").(chan bool)
        ctx := context.WithValue(r.Context(), "ready", ready)
      
        // Применяем новый контекст к запросу
        r = r.WithContext(ctx)
    
        // Принимаем только запросы с JSON телом
        if r.Header.Get("Content-Type") != "application/json" {
          http.Error(w, "", 404)
          return // Иначе останавливаем работу и отдаем 404
        }

        // Функция поиска нужного обработчика в роутере по пути
        handler, p := mux.Handler(r)
        log.Printf("Path: %v", p)
      
        // Запускаем неблокирующую функцию которая выполнится
        // в фоне, но для контроля завершения обработчика
        // передадим в нее канал и будем его слушать ниже
        go func(ch chan bool) {
      	  // Отдаем результат как JSON
          w.Header().Set("Content-Type", "application/json") 
          handler.ServeHTTP(w, r) // Вызов найденого обработчика
        }(ready)

        // Таймер дедлайна если длительность выше максимальной(5 сек)
        dead := time.NewTimer(time.Duration(5 * time.Second))

        // Возвращаем первый попавшийся канал через select
        select {
        case <-dead.C: // Канал дедлайна
          http.Error(w, "", 400) // Отдаем статус 400 если время вышло
          w.Header().Set("Content-Type", "application/json")
          resp, err := json.Marshal(map[string]string{
              "error": "timeout too long",
          })
          if err != nil {
            http.Error(w, "", 404)
            return
          }
          _, _ = w.Write(resp)
          return
        case found := <-ready: // Слушаем канал ответов на получение данных
          switch found { // Селектор полученного значения от обработчика 
          case true: // Найден
          	w.Header().Set("Content-Type", "application/json")
            resp, err := json.Marshal(map[string]string{
              "status": "ok",
            })
            if err != nil {
              http.Error(w, "", 404)
              return
            }
            _, _ = w.Write(resp)
          case false: // Не найден
            w.WriteHeader(404)
            _, _ = w.Write(nil)
          }
          return
        }
      }
    }
    ```
- Вернемся в ``main.go`` что бы прописать миддлвейр в сервер.
    ```go
    srv := http.Server{
      Addr:    ":8080",
      // В миддлвейр в качестве параметра передаем mux роутер
      // Миддлвейр пропустит к обработчику роутера если все
      // условия будут выполнены(см. middleware.go)
      Handler: filterMiddleware(mux),
    }
    ```